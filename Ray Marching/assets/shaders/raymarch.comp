#version 460 core

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (rgba8, binding = 0) uniform image2D img_output;

uniform uint width;
uniform uint height;

uniform uint numSDFObjects;
uniform uint numPointLights;
uniform uint numDirectionalLights;

uniform mat4 inverseProjectionMatrix;
uniform mat4 inverseViewMatrix;

uniform vec3 cameraOrigin;

//const uint MAX_STEPS = 200;
const float MAX_DISTANCE = 100;
const float EPSILON = 0.001;

// need this because using vec3 in the bufferobject
// made the objects use more bytes than they should use
struct SDFObjectTrash 
{
    float position[3];
    float rotation[3];
    float scale[3];
    float ambientColor[3];
    float diffuseColor[3];
    uint type; // 0 Sphere, 1 Box, 2 Torus
};

struct PointLight
{
    vec3 position;
    vec3 color;
    uint lightFalloffType; // 0 None, 1 Linear, 2 Quadractic
    float intensity;
};

struct DirectionalLight 
{
    vec3 direction;
    vec3 color;
};

layout(std430, binding = 1) buffer SDFObjectsBuffer
{
    SDFObjectTrash sdfObjects[];
};

layout(std430, binding = 2) buffer PointLightsBuffer
{
    PointLight pointLights[];
};

layout(std430, binding = 3) buffer DirectionalLightsBuffer
{
    DirectionalLight directionalLights[];
};

struct Transform 
{
    vec3 position;
    vec3 rotation;
    vec3 scale;
};

struct Material 
{
    vec3 ambientColor;
    vec3 diffuseColor;
};

struct SDFObject 
{
    Transform transform;
    Material material;
    uint type; // 0 Sphere, 1 Box, 2 Torus
};

struct Ray 
{
    vec3 origin;
    vec3 direction;
};

struct HitInfo 
{
    float minDistance;
    float totalDistance;
    bool hit;
    SDFObject object;
    vec3 surfacePoint;
};

struct SceneInfo 
{
    float distance;
    int index;
};

SDFObject trashToObject(SDFObjectTrash trash) 
{
    SDFObject object;
    object.transform.position = vec3(trash.position[0], trash.position[1], trash.position[2]);
    object.transform.rotation = vec3(trash.rotation[0], trash.rotation[1], trash.rotation[2]);
    object.transform.scale = vec3(trash.scale[0], trash.scale[1], trash.scale[2]);
    object.material.ambientColor = vec3(trash.ambientColor[0], trash.ambientColor[1], trash.ambientColor[2]);
    object.material.diffuseColor = vec3(trash.diffuseColor[0], trash.diffuseColor[1], trash.diffuseColor[2]);
    object.type = trash.type;
    return object;
}

float sd_Sphere(SDFObject sphere, vec3 point) 
{
    return length((point - sphere.transform.position) / sphere.transform.scale) - 1.0;
}

float sd_Box(SDFObject box, vec3 point) 
{
    vec3 center = box.transform.position;
    vec3 size = box.transform.scale;
    vec3 p = point - center;
    vec3 q = abs(p) - size;
    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));
}

float sd_Torus(SDFObject torus, vec3 point) 
{
    vec3 center = torus.transform.position;
    vec2 size = torus.transform.scale.xy;
    vec3 p = point - center;
    vec2 q = vec2(length(p.xz) - size.x, p.y);
    return length(q) - size.y;
}

SceneInfo sceneInfo(vec3 point) 
{
    SceneInfo sceneInfo;
    sceneInfo.distance = MAX_DISTANCE;
    sceneInfo.index = 0;

    for (int i = 0; i < numSDFObjects; i++) 
    {
        SDFObject object = trashToObject(sdfObjects[i]);
        float localDistance;
        switch (object.type)
        {
            case 0: // Sphere
                localDistance = sd_Sphere(object, point);
                break;
            case 1: // Box
                localDistance = sd_Box(object, point);
                break;
            case 2: // Torus
                localDistance = sd_Torus(object, point);
                break;
        }
        if (localDistance < sceneInfo.distance) 
        {
            sceneInfo.distance = localDistance;
            sceneInfo.index = i;
        }
    }
    return sceneInfo;
}

HitInfo rayMarch(Ray ray) 
{
    HitInfo hitInfo;
    hitInfo.totalDistance = 0.0;
    hitInfo.minDistance = MAX_DISTANCE;
    hitInfo.hit = false;
    
    while (hitInfo.totalDistance < MAX_DISTANCE)
    {
        vec3 point = ray.origin + ray.direction * hitInfo.totalDistance;

        SceneInfo sceneInfo = sceneInfo(point);

        if (sceneInfo.distance < EPSILON) 
        {
            hitInfo.minDistance = sceneInfo.distance;
            hitInfo.hit = true;
            hitInfo.surfacePoint = point;
            hitInfo.object = trashToObject(sdfObjects[sceneInfo.index]);
            break;
        }

        if (sceneInfo.distance < hitInfo.minDistance)
        {
            hitInfo.minDistance = sceneInfo.distance;
        }

        hitInfo.totalDistance += sceneInfo.distance;
        if (hitInfo.totalDistance > MAX_DISTANCE) 
        {
            break;
        }
    }

    return hitInfo;
}

vec3 approximateNormal(vec3 point) 
{
    float x = sceneInfo(vec3(point.x + EPSILON, point.yz)).distance - sceneInfo(vec3(point.x - EPSILON, point.yz)).distance;
    float y = sceneInfo(vec3(point.x, point.y + EPSILON, point.z)).distance - sceneInfo(vec3(point.x, point.y - EPSILON, point.z)).distance;
    float z = sceneInfo(vec3(point.xy, point.z + EPSILON)).distance - sceneInfo(vec3(point.xy, point.z - EPSILON)).distance;
    return normalize(vec3(x, y, z));
}

vec3 calculateLighting(DirectionalLight light, vec3 normal, vec3 viewDir, Material material) 
{
    float dotNL = dot(normal, light.direction);
    vec3 diffuse = material.diffuseColor * max(dotNL, 0.0) * light.color;

    return material.ambientColor + diffuse;
}

void main()
{
    vec2 pixel_coords = vec2(gl_GlobalInvocationID.xy);

    if (pixel_coords.x >= width || pixel_coords.y >= height) 
    {
        return;
    }

    vec2 uv = vec2(pixel_coords.x / width, pixel_coords.y / height) * 2.0 - 1.0;

    Ray ray;

    ray.origin = cameraOrigin;
    vec4 target = inverseProjectionMatrix * vec4(uv, 1.0, 1.0);
    ray.direction = vec3(inverseViewMatrix * vec4(normalize(vec3(target) / target.w), 0));

    DirectionalLight light;
    light.direction = vec3(1, 1, 0);
    light.color = vec3(1, 1, 1); 

    HitInfo hitInfo = rayMarch(ray);

    if (!hitInfo.hit) // return early if it didnt hit
    {
        vec4 pixel = vec4(0.1, 0.1, 0.1, 1.0);
        imageStore(img_output, ivec2(gl_GlobalInvocationID.xy), pixel);
        return;
    }
    
    vec3 normal = approximateNormal(hitInfo.surfacePoint - (ray.direction * EPSILON));

    vec3 viewDir = normalize(cameraOrigin - hitInfo.surfacePoint);
    vec3 lighting = calculateLighting(light, normal, viewDir, hitInfo.object.material);
    vec4 pixel = vec4(lighting, 1.0);

    imageStore(img_output, ivec2(gl_GlobalInvocationID.xy), pixel);
}
