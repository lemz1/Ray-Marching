#version 460 core

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (rgba8, binding = 0) uniform image2D img_output;

uniform uint width;
uniform uint height;

uniform uint numSDFObjects;
uniform uint numPointLights;
uniform uint numDirectionalLights;

uniform float verticalFOV;
uniform float aspectRatio;
uniform vec3 cameraOrigin;
uniform vec3 cameraTarget;

//const uint MAX_STEPS = 200;
const float MAX_DISTANCE = 50;
const float epsilon = 0.001;

// need this because using vec3 in the bufferobject
// made the objects use more bytes than they should use
struct SDFObjectTrash 
{
    float position[3];
    float rotation[3];
    float scale[3];
    float ambientColor[3];
    float diffuseColor[3];
    float specularColor[3];
    float shininess;
    uint type; // 0 Sphere, 1 Box, 2 Torus
};

struct PointLight
{
    vec3 position;
    vec3 color;
    uint lightFalloffType; // 0 None, 1 Linear, 2 Quadractic
    float intensity;
};

struct DirectionalLight 
{
    vec3 direction;
    vec3 color;
};

layout(std430, binding = 1) buffer SDFObjectsBuffer
{
    SDFObjectTrash sdfObjects[];
};

layout(std430, binding = 2) buffer PointLightsBuffer
{
    PointLight pointLights[];
};

layout(std430, binding = 3) buffer DirectionalLightsBuffer
{
    DirectionalLight directionalLights[];
};

struct Transform 
{
    vec3 position;
    vec3 rotation;
    vec3 scale;
};

struct Material 
{
    vec3 ambientColor;
    vec3 diffuseColor;
    vec3 specularColor;
    float shininess;
};

struct SDFObject 
{
    Transform transform;
    Material material;
    uint type; // 0 Sphere, 1 Box, 2 Torus
};

struct Ray 
{
    vec3 origin;
    vec3 direction;
};

struct HitInfo 
{
    float minDistance;
    float totalDistance;
    bool hit;
    uint index;
    SDFObject object;
    vec3 surfacePoint;
};

SDFObject trashToObject(SDFObjectTrash trash) 
{
    SDFObject object;
    object.transform.position = vec3(trash.position[0], trash.position[1], trash.position[2]);
    object.transform.rotation = vec3(trash.rotation[0], trash.rotation[1], trash.rotation[2]);
    object.transform.scale = vec3(trash.scale[0], trash.scale[1], trash.scale[2]);
    object.material.ambientColor = vec3(trash.ambientColor[0], trash.ambientColor[1], trash.ambientColor[2]);
    object.material.diffuseColor = vec3(trash.diffuseColor[0], trash.diffuseColor[1], trash.diffuseColor[2]);
    object.material.specularColor = vec3(trash.specularColor[0], trash.specularColor[1], trash.specularColor[2]);
    object.material.shininess = trash.shininess;
    object.type = trash.type;
    return object;
}

float sd_Sphere(SDFObject sphere, vec3 point) 
{
    return length((point - sphere.transform.position) / sphere.transform.scale) - 1.0;
}

float sd_Box(SDFObject box, vec3 point) 
{
    vec3 center = box.transform.position;
    vec3 size = box.transform.scale;
    vec3 p = point - center;
    vec3 q = abs(p) - size;
    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));
}

float sd_Torus(SDFObject torus, vec3 point) 
{
    vec3 center = torus.transform.position;
    vec2 size = torus.transform.scale.xy;
    vec3 p = point - center;
    vec2 q = vec2(length(p.xz) - size.x, p.y);
    return length(q) - size.y;
}

vec3 calculateNormalSphere(SDFObject sphere, vec3 point) 
{
    return normalize(point - sphere.transform.position);
}

vec3 calculateNormalBox(SDFObject box, vec3 point) 
{
    vec3 normal = vec3(0.0);
    vec3 center = box.transform.position;
    vec3 size = box.transform.scale;
    vec3 p = (point - center) / size;
    if (abs(p.x) > abs(p.y) && abs(p.x) > abs(p.z))
        normal = vec3(sign(p.x), 0.0, 0.0);
    else if (abs(p.y) > abs(p.z))
        normal = vec3(0.0, sign(p.y), 0.0);
    else
        normal = vec3(0.0, 0.0, sign(p.z));
    return normal;
}

vec3 calculateNormalTorus(SDFObject torus, vec3 point) 
{
    vec3 normal = vec3(0.0);
    vec3 center = torus.transform.position;
    vec3 size = torus.transform.scale;
    vec3 p = point - center;
    float r = length(p);
    float theta = atan(p.y, p.x);
    float phi = acos(p.z / r);
    normal.x = cos(theta) * sin(phi);
    normal.y = sin(theta) * sin(phi);
    normal.z = cos(phi);
    return normal;
}


vec3 calculateLighting(DirectionalLight light, vec3 normal, vec3 viewDir, Material material) 
{
    float dotNL = dot(normal, light.direction);
    vec3 diffuse = material.diffuseColor * max(dotNL, 0.0) * light.color;

    vec3 halfwayDir = normalize(light.direction + viewDir);
    float specularIntensity = pow(max(dot(normal, halfwayDir), 0.0), material.shininess);
    vec3 specular = material.specularColor * specularIntensity * light.color;

    return material.ambientColor + diffuse + specular;
}

HitInfo rayMarch(Ray ray) 
{
    HitInfo hitInfo;
    hitInfo.totalDistance = 0.0;
    hitInfo.minDistance = MAX_DISTANCE;
    hitInfo.hit = false;
    hitInfo.index = 0;
    
    while (hitInfo.totalDistance < MAX_DISTANCE)
    {
        vec3 point = ray.origin + ray.direction * hitInfo.totalDistance;

        float d = MAX_DISTANCE;

        for (int j = 0; j < numSDFObjects; j++) 
        {
            SDFObject object = trashToObject(sdfObjects[j]);
            float localD;
            switch (object.type)
            {
                case 0: // Sphere
                    localD = sd_Sphere(object, point);
                    break;
                case 1: // Box
                    localD = sd_Box(object, point);
                    break;
                case 2: // Torus
                    localD = sd_Torus(object, point);
                    break;
            }
            if (localD < d) 
            {
                d = localD;
                hitInfo.index = j;
                hitInfo.object = object;
            }
        }

        if (d < epsilon) 
        {
            hitInfo.minDistance = d;
            hitInfo.hit = true;
            hitInfo.surfacePoint = point;
            break;
        }

        hitInfo.totalDistance += d;
        if (hitInfo.totalDistance > MAX_DISTANCE) 
        {
            break;
        } 
        else if (hitInfo.totalDistance < hitInfo.minDistance)
        {
            hitInfo.minDistance = hitInfo.totalDistance;
        }
    }

    return hitInfo;
}

void main()
{
    vec2 pixel_coords = vec2(gl_GlobalInvocationID.xy);

    if (pixel_coords.x >= width || pixel_coords.y >= height) 
    {
        return;
    }

    vec2 uv = vec2(pixel_coords.x / width, pixel_coords.y / height);
    //uv.x *= float(width) / float(height);

    float theta = (3.1415926 / 180.0) * verticalFOV;
    float height = 2.0 * tan(theta / 2.0);
    float width = height * aspectRatio;

    vec3 y = vec3(0, 1, 0);
    vec3 w = normalize(cameraOrigin - cameraTarget);
    vec3 u = normalize(cross(y, w));
    vec3 v = cross(w, u);

    vec3 horizontalComp = width * u;
    vec3 verticalComp = height * v;
    vec3 bottomLeft = cameraOrigin - (horizontalComp / 2.0) - (verticalComp / 2.0) - w;

    Ray ray;

    ray.origin = cameraOrigin;
    ray.direction = bottomLeft + uv.x * horizontalComp + uv.y * verticalComp - cameraOrigin;

    DirectionalLight light;
    light.direction = vec3(1, 1, 0);
    light.color = vec3(1, 1, 1); 

    HitInfo hitInfo = rayMarch(ray);

    if (!hitInfo.hit) // return early if it didnt hit
    {
        vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0);
        imageStore(img_output, ivec2(gl_GlobalInvocationID.xy), pixel);
        return;
    }
    
    vec3 normal;
    switch (hitInfo.object.type)
    {
        case 0: // Sphere
            normal = calculateNormalSphere(hitInfo.object, hitInfo.surfacePoint);
            break;
        case 1: // Box
            normal = calculateNormalBox(hitInfo.object, hitInfo.surfacePoint);
            break;
        case 2: // Torus
            normal = calculateNormalTorus(hitInfo.object, hitInfo.surfacePoint);
            break;
    }

    vec3 viewDir = normalize(cameraOrigin - hitInfo.surfacePoint);
    vec3 lighting = calculateLighting(light, normal, viewDir, hitInfo.object.material); // Calculate the lighting
    vec4 pixel = vec4(lighting, 1.0);

    imageStore(img_output, ivec2(gl_GlobalInvocationID.xy), pixel);
}
