#version 460 core

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (rgba8, binding = 0) uniform image2D img_output;

uniform uint width;
uniform uint height;

uniform uint numSDFObjects;
uniform uint numPointLights;
uniform uint numDirectionalLights;

uniform mat4 inverseProjectionMatrix;
uniform mat4 inverseViewMatrix;

uniform vec3 cameraOrigin;

//const uint MAX_STEPS = 200;
const float MAX_DISTANCE = 100;
const float EPSILON = 0.001;

// need this because using vec3 in the bufferobject
// made the objects use more bytes than they should use
struct SDFObjectTrash 
{
    float position[3];
    float rotation[3];
    float scale[3];
    float diffuseColor[3];
    uint type; // 0 Sphere, 1 Box, 2 Torus
    float blendStrength;
};

struct PointLight
{
    vec3 position;
    vec3 color;
    uint lightFalloffType; // 0 None, 1 Linear, 2 Quadractic
    float intensity;
};

struct DirectionalLight 
{
    vec3 direction;
    vec3 color;
};

layout(std430, binding = 1) buffer SDFObjectsBuffer
{
    SDFObjectTrash sdfObjects[];
};

layout(std430, binding = 2) buffer PointLightsBuffer
{
    PointLight pointLights[];
};

layout(std430, binding = 3) buffer DirectionalLightsBuffer
{
    DirectionalLight directionalLights[];
};

struct Transform 
{
    vec3 position;
    vec3 rotation;
    vec3 scale;
};

struct Material 
{
    vec3 diffuseColor;
};

struct SDFObject 
{
    Transform transform;
    Material material;
    uint type; // 0 Sphere, 1 Box, 2 Torus
    float blendStrength;
};

struct Ray 
{
    vec3 origin;
    vec3 direction;
};

struct HitInfo 
{
    float minDistance;
    float totalDistance;
    bool hit;
    Material material;
    vec3 surfacePoint;
};

struct SceneInfo 
{
    float distance;
    Material material;
};

SDFObject trashToObject(SDFObjectTrash trash) 
{
    SDFObject object;
    object.transform.position = vec3(trash.position[0], trash.position[1], trash.position[2]);
    object.transform.rotation = vec3(trash.rotation[0], trash.rotation[1], trash.rotation[2]);
    object.transform.scale = vec3(trash.scale[0], trash.scale[1], trash.scale[2]);
    object.material.diffuseColor = vec3(trash.diffuseColor[0], trash.diffuseColor[1], trash.diffuseColor[2]);
    object.type = trash.type;
    object.blendStrength = trash.blendStrength;
    return object;
}

float sd_Sphere(SDFObject sphere, vec3 point) 
{
    vec3 center = sphere.transform.position;
    float radius = sphere.transform.scale.x;
    vec3 p = point - center;
    return length(p) - radius;
}

float sd_Box(SDFObject box, vec3 point) 
{
    vec3 center = box.transform.position;
    vec3 size = box.transform.scale;
    vec3 p = point - center;
    vec3 q = abs(p) - size;
    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));
}

float sd_Torus(SDFObject torus, vec3 point) 
{
    vec3 center = torus.transform.position;
    vec2 size = torus.transform.scale.xy;
    vec3 p = point - center;
    vec2 q = vec2(length(p.xz) - size.x, p.y);
    return length(q) - size.y;
}

float getShapeDistance(SDFObject object, vec3 point) 
{
    float distance = MAX_DISTANCE;

    switch (object.type)
    {
        case 0: // Sphere
            distance = sd_Sphere(object, point);
            break;
        case 1: // Box
            distance = sd_Box(object, point);
            break;
        case 2: // Torus
            distance = sd_Torus(object, point);
            break;
    }

    return distance;
}

float lerp(float a, float b, float t) 
{
    return a + ((b - a) * t);
}

vec3 lerp(vec3 a, vec3 b, float t) 
{
    return vec3(
        lerp(a.x, b.x, t),
        lerp(a.y, b.y, t),
        lerp(a.z, b.z, t)
    );
}

// https://www.iquilezles.org/www/articles/smin/smin.htm
SceneInfo blend(float distanceA, float distanceB, Material materialA, Material materialB, float k)
{
    SceneInfo blendInfo;

    float h = clamp(0.5+0.5*(distanceB-distanceA)/k, 0.0, 1.0);
    float blendDistance = lerp(distanceB, distanceA, h) - k*h*(1.0-h);
    vec3 blendDiffuseColor = lerp(materialB.diffuseColor, materialA.diffuseColor, h);

    blendInfo.distance = blendDistance;
    blendInfo.material.diffuseColor = blendDiffuseColor;
    return blendInfo;
}

SceneInfo intersect(float distanceA, float distanceB, Material materialA, Material materialB) 
{
    SceneInfo intersectionInfo;
    intersectionInfo.distance = distanceA;
    intersectionInfo.material = materialB;

    if (distanceB > distanceA) 
    {
        intersectionInfo.distance = distanceB;
        intersectionInfo.material = materialB;
    }

    return intersectionInfo;
}

SceneInfo substract(float distanceA, float distanceB, Material materialA, Material materialB) 
{
    SceneInfo intersectionInfo;
    intersectionInfo.distance = distanceA;
    intersectionInfo.material = materialA;

    if (-distanceB > distanceA) 
    {
        intersectionInfo.distance = -distanceB;
        intersectionInfo.material = materialB;
    }

    return intersectionInfo;
}

SceneInfo combine(float distanceA, float distanceB, Material materialA, Material materialB, uint combineType, float blendStrength) 
{
    SceneInfo sceneInfo;
    sceneInfo.distance = distanceA;
    sceneInfo.material = materialA;

    switch (combineType) 
    {
        case 0: // none
            if (distanceB < distanceA) 
            {
                sceneInfo.distance = distanceB;
                sceneInfo.material = materialB;
            }
            break;
        case 1: // blending
            sceneInfo = blend(distanceA, distanceB, materialA, materialB, blendStrength);
            break;
        case 2: // intersection
            sceneInfo = intersect(distanceA, distanceB, materialA, materialB);
            break;
        case 3: // susbstraction
            sceneInfo = substract(distanceA, distanceB, materialA, materialB);
            break;
    }

    return sceneInfo;
}

SceneInfo sceneInfo(vec3 point) 
{
    SceneInfo sceneInfo;
    sceneInfo.distance = MAX_DISTANCE;
    sceneInfo.material = Material(vec3(0.1));

    for (int i = 0; i < numSDFObjects; i++) 
    {
        SDFObject object = trashToObject(sdfObjects[i]);
        float localDistance = getShapeDistance(object, point);
        Material localMaterial = object.material;

        for (int j = i + 1; j < numSDFObjects; j++) 
        {
            SDFObject otherObject = trashToObject(sdfObjects[j]);
            float otherDistance = getShapeDistance(otherObject, point);
            Material otherMaterial = otherObject.material;

            SceneInfo combineInfo = combine(localDistance, otherDistance, localMaterial, otherMaterial, 1, otherObject.blendStrength);
            localDistance = combineInfo.distance;
            localMaterial = combineInfo.material;
        }
        i += int(numSDFObjects);

        if (localDistance < sceneInfo.distance) 
        {
            sceneInfo.distance = localDistance;
            sceneInfo.material = localMaterial;
        }
    }
    return sceneInfo;
}

HitInfo rayMarch(Ray ray) 
{
    HitInfo hitInfo;
    hitInfo.totalDistance = 0.0;
    hitInfo.minDistance = MAX_DISTANCE;
    hitInfo.hit = false;
    
    while (hitInfo.totalDistance < MAX_DISTANCE)
    {
        vec3 point = ray.origin + ray.direction * hitInfo.totalDistance;

        SceneInfo sceneInfo = sceneInfo(point);

        if (sceneInfo.distance < EPSILON) 
        {
            hitInfo.minDistance = sceneInfo.distance;
            hitInfo.hit = true;
            hitInfo.material = sceneInfo.material;
            hitInfo.surfacePoint = point;
            break;
        }

        if (sceneInfo.distance < hitInfo.minDistance)
        {
            hitInfo.minDistance = sceneInfo.distance;
        }

        hitInfo.totalDistance += sceneInfo.distance;
        if (hitInfo.totalDistance > MAX_DISTANCE) 
        {
            break;
        }
    }

    return hitInfo;
}

vec3 approximateNormal(vec3 point) 
{
    float x = sceneInfo(vec3(point.x + EPSILON, point.yz)).distance - sceneInfo(vec3(point.x - EPSILON, point.yz)).distance;
    float y = sceneInfo(vec3(point.x, point.y + EPSILON, point.z)).distance - sceneInfo(vec3(point.x, point.y - EPSILON, point.z)).distance;
    float z = sceneInfo(vec3(point.xy, point.z + EPSILON)).distance - sceneInfo(vec3(point.xy, point.z - EPSILON)).distance;
    return normalize(vec3(x, y, z));
}

vec3 calculateLighting(DirectionalLight light, vec3 normal, vec3 viewDir, Material material) 
{
    float dotNL = dot(normal, light.direction);
    vec3 diffuse = material.diffuseColor * max(dotNL, 0.0) * light.color;

    float ambientStrength = 0.2;
    vec3 ambient = ambientStrength * material.diffuseColor;

    return ambient + diffuse;
}


void main()
{
    vec2 pixel_coords = vec2(gl_GlobalInvocationID.xy);

    if (pixel_coords.x >= width || pixel_coords.y >= height) 
    {
        return;
    }

    vec2 uv = vec2(pixel_coords.x / width, pixel_coords.y / height) * 2.0 - 1.0;

    Ray ray;

    ray.origin = cameraOrigin;
    vec4 target = inverseProjectionMatrix * vec4(uv, 1.0, 1.0);
    ray.direction = vec3(inverseViewMatrix * vec4(normalize(vec3(target) / target.w), 0));
    
    // i am doing this because i want a bigger z value to mean further from the camera (relative to default camera rotation)
    // i think this has something to do with left-hand and right-hand coordinate system (i dont know)
    // all that matters is that this makes it work
    // theres probably a more sophisticated way
    ray.origin.z *= -1;
    ray.direction.z *= -1;

    DirectionalLight light;
    light.direction = vec3(1, 1, 0);
    light.color = vec3(1, 1, 1); 

    HitInfo hitInfo = rayMarch(ray);

    if (!hitInfo.hit) // return early if it didnt hit
    {
        vec4 pixel = vec4(0.1, 0.1, 0.1, 1.0);
        imageStore(img_output, ivec2(gl_GlobalInvocationID.xy), pixel);
        return;
    }
    
    vec3 normal = approximateNormal(hitInfo.surfacePoint - (ray.direction * EPSILON));

    vec3 viewDir = normalize(cameraOrigin - hitInfo.surfacePoint);
    vec3 lighting = calculateLighting(light, normal, viewDir, hitInfo.material);
    vec4 pixel = vec4(lighting, 1.0);

    imageStore(img_output, ivec2(gl_GlobalInvocationID.xy), pixel);
}
