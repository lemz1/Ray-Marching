#version 460 core

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (rgba8, binding = 0) uniform image2D img_output;

uniform uint width;
uniform uint height;

struct Light 
{
    vec3 direction;
    vec3 color;
};

struct Ray 
{
    vec3 origin;
    vec3 direction;
};

struct HitInfo 
{
    float minDistance;
    float totalDistance;
    bool hit;
};

struct Sphere 
{
    vec3 origin;
    float radius;
};

float sd_Sphere(Sphere sphere, vec3 point) 
{
    return length(point - sphere.origin) - sphere.radius;
}

vec3 calculateLighting(Light light, vec3 normal) 
{
    float dotNL = dot(normal, light.direction);
    vec3 diffuse = max(dotNL, 0.0) * light.color;
    return diffuse;
}

const uint MAX_STEPS = 100;
const float MAX_DISTANCE = 100;
const float epsilon = 0.01;
HitInfo rayMarch(Ray ray, Sphere sphere) 
{
    HitInfo hitInfo;
    hitInfo.totalDistance = 0.0;
    hitInfo.minDistance = MAX_DISTANCE;
    hitInfo.hit = false;
    
    for (int i = 0; i < MAX_STEPS; i++) 
    {
        vec3 point = ray.origin + ray.direction * hitInfo.totalDistance;
        float d = sd_Sphere(sphere, point);

        if (d < epsilon) 
        {
            hitInfo.minDistance = d;
            hitInfo.hit = true;
            break;
        }

        hitInfo.totalDistance += d;
        if (hitInfo.totalDistance > MAX_DISTANCE) 
        {
            break;
        } 
        else if (hitInfo.totalDistance < hitInfo.minDistance)
        {
            hitInfo.minDistance = hitInfo.totalDistance;
        }
    }

    return hitInfo;
}

void main()
{
    vec2 pixel_coords = vec2(gl_GlobalInvocationID.xy);

    if (pixel_coords.x >= width || pixel_coords.y >= height) 
    {
        return;
    }

    vec2 uv = vec2(pixel_coords.x / width, pixel_coords.y / height) * 2.0 - 1.0;
    uv.x *= float(width) / float(height);

    Sphere sphere;
    sphere.radius = 1.0;
    sphere.origin = vec3(0, 0, 0);

    Light light;
    light.direction = normalize(vec3(1, 1, 0)); // Set the direction of the light
    light.color = vec3(1, 1, 1); // Set the color of the light

    Ray ray;
    ray.origin = vec3(0, 0, -2); // Set the origin of the ray
    ray.direction = normalize(vec3(uv, 1)); // Set the direction of the ray

    HitInfo hitInfo = rayMarch(ray, sphere);
    vec4 pixel;

    if (hitInfo.minDistance < epsilon) // If the ray hits the sphere
    {
        vec3 normal = normalize(ray.origin + ray.direction * hitInfo.totalDistance - sphere.origin); // Calculate the normal
        vec3 lighting = calculateLighting(light, normal); // Calculate the lighting
        vec3 ambientColor = vec3(0.2, 0.0, 0.0);
        vec3 diffuseColor = vec3(1.0, 0.0, 0.0);
        pixel = vec4(ambientColor + diffuseColor * lighting, 1.0); // Set the pixel color to the lighting
    }
    else
    {
        pixel = vec4(0.0, 0.0, 0.0, 1.0); // Set the pixel color to black
    }

    imageStore(img_output, ivec2(gl_GlobalInvocationID.xy), pixel);
}
